# test_100_5.py
# coding: utf-8
'''
题目：实现一个栈，带有出栈（pop），入栈（push），
取最小元素（getMin）三个方法。要保证这三个方法的时间复杂度都是O（1）

解法：

1.设原有的栈叫做栈A，此时创建一个额外的栈B，用于辅助原栈A。

2.当第一个元素进入栈A的时候，让新元素的下标进入栈B。这个唯一的元素是栈A的当前最小值。（考虑到栈中元素可能不是类对象，所以B栈存储的是A栈元素的下标）

3.每当新元素进入栈A时，比较新元素和栈A当前最小值的大小，如果小于栈A当前最小值，则让新元素的下标进入栈B，此时栈B的栈顶元素就是栈A当前最小值的下标。

4.每当栈A有元素出栈时，如果出栈元素是栈A当前最小值，则让栈B的栈顶元素也出栈。此时栈B余下的栈顶元素所指向的，是栈A当中原本第二小的元素，代替刚才的出栈元素成为了栈A的当前最小值。（备胎转正）

5.当调用getMin方法的时候，直接返回栈B的栈顶所指向的栈A对应元素即可。


题目：实现一个方法，
判断一个正整数是否是2的乘方（比如16是2的4次方，返回True；18不是2的乘方，返回False）。
要求性能尽可能高。

N&N-1 ==0 O(1)
非常有趣也非常简单的解法。因为2的乘方都符合一个规律，即 N&N-1 等于 0，
所以直接用这个规律判断即可。该算法时间复杂度是O（1）。
'''
def check_2mi(number):
	if number&(number-1)==0:
		return True
	else:
		return False
if __name__ == '__main__':
	number = 1024
	print check_2mi(number)